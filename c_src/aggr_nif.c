#include "erl_nif.h"
#include "mmath.h"

#include <math.h>
#include <stdio.h>

typedef ffloat (*aggr_func2) (ffloat, ffloat);
typedef ffloat (*aggr_func3) (ffloat, ffloat, double);
typedef ffloat (*emit_func) (ffloat, double);

void print(ffloat* vs, uint32_t count) {
  for (uint32_t i = 0; i < count; i++) {
    printf("%.2f(%.2f) ", vs[i].value, vs[i].confidence);
  };
  printf("\n\r");
}

static int
load(ErlNifEnv* env, void** priv, ERL_NIF_TERM load_info)
{
  return 0;
}

static int
upgrade(ErlNifEnv* env, void** priv, void** old_priv, ERL_NIF_TERM load_info)
{
  return 0;
}

static ERL_NIF_TERM
aggr2(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[], aggr_func2 f, emit_func g)
{
  ErlNifBinary bin;
  ErlNifSInt64 chunk;         // size to be compressed

  ERL_NIF_TERM r;
  ffloat* vs;
  ffloat* target;
  ffloat aggr;          // Aggregator
  double confidence;

  uint32_t target_i = 0;      // target position
  uint32_t count;
  uint32_t pos = 0;
  uint32_t target_size;

  if (argc != 2)
    return enif_make_badarg(env);

  GET_CHUNK(chunk);
  GET_BIN(0, bin, count, vs);

  target_size = ceil((double) count / chunk) * sizeof(ffloat);
  if (! (target = (ffloat*) enif_make_new_binary(env, target_size, &r)))
    return enif_make_badarg(env); // TODO return propper error
  if (count > 0) {
    aggr = vs[0];
    confidence = aggr.confidence;
    pos = 1;
    //We will be overwriting the confidence generated by dec_add because
    //it would give a false impression based on the later values having
    //a higher influence.
    for (uint32_t i = 1; i < count; i++, pos++) {
      if (pos == chunk) {
        aggr.confidence = confidence / chunk;
        target[target_i] = g(aggr, chunk);
        target_i++;
        aggr = vs[i];
        confidence = aggr.confidence;
        pos = 0;
      } else {
        confidence += vs[i].confidence;
        aggr = f(aggr, vs[i]);
      }
    }

    if (count % chunk) {
      for (uint32_t i = 0; i < (chunk - (count % chunk)); i++) {
          aggr = f(aggr, vs[count-1]);
      }
    }

    aggr.confidence = confidence / chunk;
    target[target_i] = g(aggr, chunk);
  }

  return r;
}

static ERL_NIF_TERM
aggr(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[], aggr_func2 f)
{
    return aggr2(env, argc, argv, f, float_const);
}

static ERL_NIF_TERM
min(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
  return aggr(env, argc, argv, float_min);
}

static ERL_NIF_TERM
max(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
  return aggr(env, argc, argv, float_max);
}

static ERL_NIF_TERM
sum(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
  return aggr(env, argc, argv, float_add);
}

static ERL_NIF_TERM
avg(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
  return aggr2(env, argc, argv, float_add, float_divc);
}

int comp (const void * elem1, const void * elem2)
{
  double f = ((ffloat*)elem1)->value;
  double s = ((ffloat*)elem2)-> value;
  if (f > s) return  1;
  if (f < s) return -1;
  return 0;
}

void sort(ffloat* vs, uint32_t count) {
  qsort(vs, count, sizeof(ffloat), comp);
}

// TODO: investigate quickselect https://en.wikipedia.org/wiki/Quickselect
static ERL_NIF_TERM
percentile(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
  ErlNifBinary bin;
  ErlNifSInt64 chunk;         // size to be compressed
  double p;

  ERL_NIF_TERM r;
  ffloat* vs;
  ffloat* target;

  uint32_t count;
  uint32_t pos = 0;
  uint32_t target_size;

  if (argc != 3)
    return enif_make_badarg(env);


  if (!enif_get_double(env, argv[1], &p) || p < 0 || p > 1)
    return enif_make_badarg(env);

  if (!enif_get_int64(env, argv[2], &chunk) || chunk < 1)
    return enif_make_badarg(env);

  GET_BIN(0, bin, count, vs);

  target_size = ceil((double) count / chunk) * sizeof(ffloat);
  if (! (target = (ffloat*) enif_make_new_binary(env, target_size, &r)))
    return enif_make_badarg(env); // TODO return propper error
  uint32_t offset;
  for (offset = 0; (offset + chunk) <= count; offset += chunk) {
    uint32_t n = (uint32_t)((chunk - 1) * p);
    sort(&vs[offset], chunk);
    target[pos] = vs[offset + n];
    target[pos].confidence = 0;
    for (uint32_t i = 0; i < chunk; i ++) {
      target[pos].confidence += vs[offset + i].confidence;
    }
    target[pos].confidence /= chunk;
    pos++;
  }
  // if the last chunk is incomplete
  uint32_t leftover = count % chunk;
  if (leftover) {
    uint32_t n = (uint32_t)((leftover - 1) * p);
    sort(&vs[offset], leftover);
    target[pos].value = vs[offset + n].value;
    target[pos].confidence = 0;
    for (uint32_t i = 0; i < leftover; i ++) {
      double c = vs[offset + i].confidence;
      target[pos].confidence += c;
    }
    target[pos].confidence /= leftover;
  }
  return r;
}

static ERL_NIF_TERM
aggr3(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[], aggr_func3 f)
{
  ErlNifBinary bin;
  ErlNifSInt64 chunk;         // size to be compressed

  ERL_NIF_TERM r;
  ffloat* vs;
  ffloat* target;
  ffloat aggr;          // Aggregator
  double confidence;

  uint32_t target_i = 0;      // target position
  uint32_t count;
  uint32_t pos = 0;
  uint32_t target_size;
  double arg;

  if (argc != 3)
    return enif_make_badarg(env);

  GET_CHUNK(chunk);
  GET_BIN(0, bin, count, vs);

  if (!enif_get_double(env, argv[2], &arg))
    return enif_make_badarg(env);

  target_size = ceil((double) count / chunk) * sizeof(ffloat);
  if (! (target = (ffloat*) enif_make_new_binary(env, target_size, &r)))
    return enif_make_badarg(env); // TODO return propper error
  if (count > 0) {
    aggr = vs[0];
    confidence = aggr.confidence;
    pos = 1;

    for (uint32_t i = 1; i < count; i++, pos++) {
      if (pos == chunk) {
        aggr.confidence = confidence / chunk;
        target[target_i] = aggr;
        target_i++;
        aggr = vs[i];
        confidence = aggr.confidence;
        pos = 0;
      } else {
        confidence += vs[i].confidence;
        aggr = f(aggr, vs[i], arg);
      }
    }

    if (count % chunk) {
      for (uint32_t i = 0; i < (chunk - (count % chunk)); i++) {
          aggr = f(aggr, vs[count-1], arg);
      }
    }

    aggr.confidence = confidence / chunk;
    target[target_i] = aggr;
  }

  return r;
}

static ERL_NIF_TERM
first_below(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
  return aggr3(env, argc, argv, float_first_below);
}

static ErlNifFunc nif_funcs[] = {
  {"min",        2, min},
  {"max",        2, max},
  {"sum",        2, sum},
  {"avg",        2, avg},
  {"percentile", 3, percentile},
  {"first_below", 3, first_below}
};

// Initialize this NIF library.
//
// Args: (MODULE, ErlNifFunc funcs[], load, reload, upgrade, unload)
// Docs: http://erlang.org/doc/man/erl_nif.html#ERL_NIF_INIT

ERL_NIF_INIT(mmath_aggr, nif_funcs, &load, NULL, &upgrade, NULL);
